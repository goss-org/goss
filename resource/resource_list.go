// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package resource

import (
	"encoding/json"

	"github.com/aelsabbahy/goss/system"
	"github.com/aelsabbahy/goss/util"
)

//go:generate sed -i -e "/^\\/\\/ +build genny/d" resource_list.go
//go:generate goimports -w resource_list.go resource_list.go

type AddrMap map[string]*Addr

func (r AddrMap) AppendSysResource(sr string, sys *system.System, config util.Config) (*Addr, error) {
	sysres := sys.NewAddr(sr, sys, config)
	res, err := NewAddr(sysres, config)
	if err != nil {
		return nil, err
	}
	r[res.ID()] = res
	return res, nil
}

func (r AddrMap) AppendSysResourceIfExists(sr string, sys *system.System) (*Addr, system.Addr, bool) {
	sysres := sys.NewAddr(sr, sys, util.Config{})
	// FIXME: Do we want to be silent about errors?
	res, _ := NewAddr(sysres, util.Config{})
	if e, _ := sysres.Exists(); e != true {
		return res, sysres, false
	}
	r[res.ID()] = res
	return res, sysres, true
}

func (r *AddrMap) UnmarshalJSON(data []byte) error {
	var tmp map[string]*Addr
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}

	for id, res := range tmp {
		res.SetID(id)
	}

	*r = tmp

	return nil
}

//go:generate sed -i -e "/^\\/\\/ +build genny/d" resource_list.go
//go:generate goimports -w resource_list.go resource_list.go

type CommandMap map[string]*Command

func (r CommandMap) AppendSysResource(sr string, sys *system.System, config util.Config) (*Command, error) {
	sysres := sys.NewCommand(sr, sys, config)
	res, err := NewCommand(sysres, config)
	if err != nil {
		return nil, err
	}
	r[res.ID()] = res
	return res, nil
}

func (r CommandMap) AppendSysResourceIfExists(sr string, sys *system.System) (*Command, system.Command, bool) {
	sysres := sys.NewCommand(sr, sys, util.Config{})
	// FIXME: Do we want to be silent about errors?
	res, _ := NewCommand(sysres, util.Config{})
	if e, _ := sysres.Exists(); e != true {
		return res, sysres, false
	}
	r[res.ID()] = res
	return res, sysres, true
}

func (r *CommandMap) UnmarshalJSON(data []byte) error {
	var tmp map[string]*Command
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}

	for id, res := range tmp {
		res.SetID(id)
	}

	*r = tmp

	return nil
}

//go:generate sed -i -e "/^\\/\\/ +build genny/d" resource_list.go
//go:generate goimports -w resource_list.go resource_list.go

type DNSMap map[string]*DNS

func (r DNSMap) AppendSysResource(sr string, sys *system.System, config util.Config) (*DNS, error) {
	sysres := sys.NewDNS(sr, sys, config)
	res, err := NewDNS(sysres, config)
	if err != nil {
		return nil, err
	}
	r[res.ID()] = res
	return res, nil
}

func (r DNSMap) AppendSysResourceIfExists(sr string, sys *system.System) (*DNS, system.DNS, bool) {
	sysres := sys.NewDNS(sr, sys, util.Config{})
	// FIXME: Do we want to be silent about errors?
	res, _ := NewDNS(sysres, util.Config{})
	if e, _ := sysres.Exists(); e != true {
		return res, sysres, false
	}
	r[res.ID()] = res
	return res, sysres, true
}

func (r *DNSMap) UnmarshalJSON(data []byte) error {
	var tmp map[string]*DNS
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}

	for id, res := range tmp {
		res.SetID(id)
	}

	*r = tmp

	return nil
}

//go:generate sed -i -e "/^\\/\\/ +build genny/d" resource_list.go
//go:generate goimports -w resource_list.go resource_list.go

type FileMap map[string]*File

func (r FileMap) AppendSysResource(sr string, sys *system.System, config util.Config) (*File, error) {
	sysres := sys.NewFile(sr, sys, config)
	res, err := NewFile(sysres, config)
	if err != nil {
		return nil, err
	}
	r[res.ID()] = res
	return res, nil
}

func (r FileMap) AppendSysResourceIfExists(sr string, sys *system.System) (*File, system.File, bool) {
	sysres := sys.NewFile(sr, sys, util.Config{})
	// FIXME: Do we want to be silent about errors?
	res, _ := NewFile(sysres, util.Config{})
	if e, _ := sysres.Exists(); e != true {
		return res, sysres, false
	}
	r[res.ID()] = res
	return res, sysres, true
}

func (r *FileMap) UnmarshalJSON(data []byte) error {
	var tmp map[string]*File
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}

	for id, res := range tmp {
		res.SetID(id)
	}

	*r = tmp

	return nil
}

//go:generate sed -i -e "/^\\/\\/ +build genny/d" resource_list.go
//go:generate goimports -w resource_list.go resource_list.go

type GossfileMap map[string]*Gossfile

func (r GossfileMap) AppendSysResource(sr string, sys *system.System, config util.Config) (*Gossfile, error) {
	sysres := sys.NewGossfile(sr, sys, config)
	res, err := NewGossfile(sysres, config)
	if err != nil {
		return nil, err
	}
	r[res.ID()] = res
	return res, nil
}

func (r GossfileMap) AppendSysResourceIfExists(sr string, sys *system.System) (*Gossfile, system.Gossfile, bool) {
	sysres := sys.NewGossfile(sr, sys, util.Config{})
	// FIXME: Do we want to be silent about errors?
	res, _ := NewGossfile(sysres, util.Config{})
	if e, _ := sysres.Exists(); e != true {
		return res, sysres, false
	}
	r[res.ID()] = res
	return res, sysres, true
}

func (r *GossfileMap) UnmarshalJSON(data []byte) error {
	var tmp map[string]*Gossfile
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}

	for id, res := range tmp {
		res.SetID(id)
	}

	*r = tmp

	return nil
}

//go:generate sed -i -e "/^\\/\\/ +build genny/d" resource_list.go
//go:generate goimports -w resource_list.go resource_list.go

type GroupMap map[string]*Group

func (r GroupMap) AppendSysResource(sr string, sys *system.System, config util.Config) (*Group, error) {
	sysres := sys.NewGroup(sr, sys, config)
	res, err := NewGroup(sysres, config)
	if err != nil {
		return nil, err
	}
	r[res.ID()] = res
	return res, nil
}

func (r GroupMap) AppendSysResourceIfExists(sr string, sys *system.System) (*Group, system.Group, bool) {
	sysres := sys.NewGroup(sr, sys, util.Config{})
	// FIXME: Do we want to be silent about errors?
	res, _ := NewGroup(sysres, util.Config{})
	if e, _ := sysres.Exists(); e != true {
		return res, sysres, false
	}
	r[res.ID()] = res
	return res, sysres, true
}

func (r *GroupMap) UnmarshalJSON(data []byte) error {
	var tmp map[string]*Group
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}

	for id, res := range tmp {
		res.SetID(id)
	}

	*r = tmp

	return nil
}

//go:generate sed -i -e "/^\\/\\/ +build genny/d" resource_list.go
//go:generate goimports -w resource_list.go resource_list.go

type PackageMap map[string]*Package

func (r PackageMap) AppendSysResource(sr string, sys *system.System, config util.Config) (*Package, error) {
	sysres := sys.NewPackage(sr, sys, config)
	res, err := NewPackage(sysres, config)
	if err != nil {
		return nil, err
	}
	r[res.ID()] = res
	return res, nil
}

func (r PackageMap) AppendSysResourceIfExists(sr string, sys *system.System) (*Package, system.Package, bool) {
	sysres := sys.NewPackage(sr, sys, util.Config{})
	// FIXME: Do we want to be silent about errors?
	res, _ := NewPackage(sysres, util.Config{})
	if e, _ := sysres.Exists(); e != true {
		return res, sysres, false
	}
	r[res.ID()] = res
	return res, sysres, true
}

func (r *PackageMap) UnmarshalJSON(data []byte) error {
	var tmp map[string]*Package
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}

	for id, res := range tmp {
		res.SetID(id)
	}

	*r = tmp

	return nil
}

//go:generate sed -i -e "/^\\/\\/ +build genny/d" resource_list.go
//go:generate goimports -w resource_list.go resource_list.go

type PortMap map[string]*Port

func (r PortMap) AppendSysResource(sr string, sys *system.System, config util.Config) (*Port, error) {
	sysres := sys.NewPort(sr, sys, config)
	res, err := NewPort(sysres, config)
	if err != nil {
		return nil, err
	}
	r[res.ID()] = res
	return res, nil
}

func (r PortMap) AppendSysResourceIfExists(sr string, sys *system.System) (*Port, system.Port, bool) {
	sysres := sys.NewPort(sr, sys, util.Config{})
	// FIXME: Do we want to be silent about errors?
	res, _ := NewPort(sysres, util.Config{})
	if e, _ := sysres.Exists(); e != true {
		return res, sysres, false
	}
	r[res.ID()] = res
	return res, sysres, true
}

func (r *PortMap) UnmarshalJSON(data []byte) error {
	var tmp map[string]*Port
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}

	for id, res := range tmp {
		res.SetID(id)
	}

	*r = tmp

	return nil
}

//go:generate sed -i -e "/^\\/\\/ +build genny/d" resource_list.go
//go:generate goimports -w resource_list.go resource_list.go

type ProcessMap map[string]*Process

func (r ProcessMap) AppendSysResource(sr string, sys *system.System, config util.Config) (*Process, error) {
	sysres := sys.NewProcess(sr, sys, config)
	res, err := NewProcess(sysres, config)
	if err != nil {
		return nil, err
	}
	r[res.ID()] = res
	return res, nil
}

func (r ProcessMap) AppendSysResourceIfExists(sr string, sys *system.System) (*Process, system.Process, bool) {
	sysres := sys.NewProcess(sr, sys, util.Config{})
	// FIXME: Do we want to be silent about errors?
	res, _ := NewProcess(sysres, util.Config{})
	if e, _ := sysres.Exists(); e != true {
		return res, sysres, false
	}
	r[res.ID()] = res
	return res, sysres, true
}

func (r *ProcessMap) UnmarshalJSON(data []byte) error {
	var tmp map[string]*Process
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}

	for id, res := range tmp {
		res.SetID(id)
	}

	*r = tmp

	return nil
}

//go:generate sed -i -e "/^\\/\\/ +build genny/d" resource_list.go
//go:generate goimports -w resource_list.go resource_list.go

type ServiceMap map[string]*Service

func (r ServiceMap) AppendSysResource(sr string, sys *system.System, config util.Config) (*Service, error) {
	sysres := sys.NewService(sr, sys, config)
	res, err := NewService(sysres, config)
	if err != nil {
		return nil, err
	}
	r[res.ID()] = res
	return res, nil
}

func (r ServiceMap) AppendSysResourceIfExists(sr string, sys *system.System) (*Service, system.Service, bool) {
	sysres := sys.NewService(sr, sys, util.Config{})
	// FIXME: Do we want to be silent about errors?
	res, _ := NewService(sysres, util.Config{})
	if e, _ := sysres.Exists(); e != true {
		return res, sysres, false
	}
	r[res.ID()] = res
	return res, sysres, true
}

func (r *ServiceMap) UnmarshalJSON(data []byte) error {
	var tmp map[string]*Service
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}

	for id, res := range tmp {
		res.SetID(id)
	}

	*r = tmp

	return nil
}

//go:generate sed -i -e "/^\\/\\/ +build genny/d" resource_list.go
//go:generate goimports -w resource_list.go resource_list.go

type UserMap map[string]*User

func (r UserMap) AppendSysResource(sr string, sys *system.System, config util.Config) (*User, error) {
	sysres := sys.NewUser(sr, sys, config)
	res, err := NewUser(sysres, config)
	if err != nil {
		return nil, err
	}
	r[res.ID()] = res
	return res, nil
}

func (r UserMap) AppendSysResourceIfExists(sr string, sys *system.System) (*User, system.User, bool) {
	sysres := sys.NewUser(sr, sys, util.Config{})
	// FIXME: Do we want to be silent about errors?
	res, _ := NewUser(sysres, util.Config{})
	if e, _ := sysres.Exists(); e != true {
		return res, sysres, false
	}
	r[res.ID()] = res
	return res, sysres, true
}

func (r *UserMap) UnmarshalJSON(data []byte) error {
	var tmp map[string]*User
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}

	for id, res := range tmp {
		res.SetID(id)
	}

	*r = tmp

	return nil
}
